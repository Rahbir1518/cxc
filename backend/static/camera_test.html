<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Indoor Navigation - Voice & Map</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background: #16213e;
            padding: 0.75rem 1rem;
            text-align: center;
        }
        
        h1 { font-size: 1.1rem; margin-bottom: 0.25rem; }
        
        #status { font-size: 0.85rem; color: #4ecca3; }
        
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            gap: 0.75rem;
        }
        
        .server-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        
        .server-row input {
            flex: 1;
            padding: 0.6rem;
            border: none;
            border-radius: 8px;
            background: #0f0f23;
            color: white;
            font-size: 0.95rem;
        }
        
        .server-row button { padding: 0.6rem 1rem; }
        
        /* Map overlay - shown when navigating */
        #mapContainer {
            background: #0f0f23;
            border-radius: 12px;
            overflow: hidden;
            width: 100%;
            height: 220px;
            position: relative;
            display: none;
            border: 2px solid #4ecca3;
        }
        
        #mapContainer.visible { display: block; }
        
        #mapImg {
            width: 100%;
            height: 100%;
            object-fit: contain;
        }
        
        #routeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .nav-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            background: rgba(0,0,0,0.85);
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #4ecca3;
        }
        
        .video-container {
            position: relative;
            background: #0f0f23;
            border-radius: 12px;
            overflow: hidden;
            flex: 1;
            min-height: 220px;
        }
        
        #videoElement, #processedFrame {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #videoElement { z-index: 0; }
        #processedFrame { z-index: 1; background: #000; }
        /* When show-video: only show raw video until first annotated frame arrives */
        .video-container.show-video #processedFrame { opacity: 0; pointer-events: none; }
        
        .voice-prompt {
            text-align: center;
            padding: 0.5rem;
            background: #16213e;
            border-radius: 10px;
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        
        .voice-prompt strong { color: #4ecca3; }
        
        .controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 0.9rem 1.5rem;
            font-size: 0.95rem;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button:active:not(:disabled) { transform: scale(0.97); }
        
        #connectBtn { background: #4ecca3; color: #1a1a2e; }
        #startBtn { background: linear-gradient(135deg, #4ecca3, #38a3a5); color: #1a1a2e; }
        #stopBtn { background: #e74c3c; color: white; }
        #voiceNavBtn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        #voiceNavBtn.active-nav { box-shadow: 0 0 16px rgba(240, 147, 251, 0.6); }
        
        .manual-row {
            display: none;
            gap: 0.5rem;
            width: 100%;
        }
        .manual-row.visible { display: flex; }
        .manual-row input {
            flex: 1;
            padding: 0.6rem;
            border-radius: 8px;
            background: #2a2a4e;
            color: white;
            border: 1px solid #4ecca3;
        }
        
        .info-panel {
            background: #16213e;
            border-radius: 10px;
            padding: 0.75rem;
            max-height: 120px;
            overflow-y: auto;
        }
        .info-panel h2 { font-size: 0.9rem; margin-bottom: 0.35rem; color: #4ecca3; }
        #detectionList { font-size: 0.85rem; line-height: 1.5; }
        .detection-item { display: flex; justify-content: space-between; padding: 0.2rem 0; border-bottom: 1px solid #2a2a4e; }
        .distance-close { color: #e74c3c; }
        .distance-medium { color: #f39c12; }
        .distance-far { color: #4ecca3; }
    </style>
</head>
<body>
    <header>
        <h1>üß≠ Voice Navigation (Room 0020 ‚Üí destination)</h1>
        <div id="status">Enter server address and connect</div>
    </header>
    
    <div class="container">
        <div class="server-row">
            <input type="text" id="serverUrl" placeholder="Server (e.g. 192.168.1.100:8000)" value="">
            <button id="connectBtn">Connect</button>
        </div>
        
        <div id="mapContainer">
            <div class="nav-overlay" id="navInfo">Destination: ‚Äî</div>
            <img id="mapImg" alt="Floor Plan" />
            <canvas id="routeCanvas"></canvas>
        </div>
        
        <p class="voice-prompt" style="margin-bottom:0;">Camera ‚Äî you‚Äôll hear what‚Äôs in the way when you tap Announce.</p>
        <div id="videoContainer" class="video-container">
            <video id="videoElement" autoplay playsinline></video>
            <img id="processedFrame" alt="Camera with object boxes when connected">
        </div>
        
        <div id="voicePrompt" class="voice-prompt">
            After connecting, tap <strong>Start</strong> then say: <strong>"Take me to room 0010"</strong>
        </div>
        
        <div class="controls">
            <button id="startBtn" disabled>üì∑ Start</button>
            <button id="stopBtn" disabled>‚èπ Stop</button>
            <button id="announceBtn" disabled>üîä Announce</button>
            <button id="voiceNavBtn" disabled>üé§ Say destination</button>
        </div>
        
        <div id="manualEntry" class="manual-row">
            <input type="text" id="manualDest" placeholder="Room (e.g. 0010)">
            <button id="goBtn" style="padding: 0.6rem 1rem; background: #4ecca3; color: #1a1a2e; border-radius: 8px;">Go</button>
        </div>
        
        <div class="info-panel">
            <h2>Detected objects</h2>
            <div id="detectionList">Start camera to see detections.</div>
        </div>
    </div>
    
    <script>
        const serverUrlInput = document.getElementById('serverUrl');
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const videoEl = document.getElementById('videoElement');
        const processedFrame = document.getElementById('processedFrame');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const voiceNavBtn = document.getElementById('voiceNavBtn');
        const mapContainer = document.getElementById('mapContainer');
        const mapImg = document.getElementById('mapImg');
        const routeCanvas = document.getElementById('routeCanvas');
        const navInfo = document.getElementById('navInfo');
        const detectionList = document.getElementById('detectionList');
        const voicePrompt = document.getElementById('voicePrompt');
        const manualEntry = document.getElementById('manualEntry');
        const videoContainer = document.getElementById('videoContainer');
        const announceBtn = document.getElementById('announceBtn');
        
        const START_ROOM = '0020';
        
        let serverUrl = '';
        let ws = null;
        let stream = null;
        let isProcessing = false;
        let isProcessingWsFrame = false;
        let lastDetections = [];
        let lastSpokenAnnouncement = '';
        
        let isNavigating = false;
        let navPath = [];
        let navDestination = null;
        let guidanceInterval = null;
        let recognition = null;
        
        function setMapSource() {
            if (serverUrl && mapImg) {
                // Use PNG for background, much more reliable than SVG object
                mapImg.src = serverUrl + '/static/floor_plans/basement.png';
                // Reset canvas when map changes
                const ctx = routeCanvas.getContext('2d');
                ctx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);
            }
        }
        
        connectBtn.addEventListener('click', () => {
            let url = serverUrlInput.value.trim();
            if (!url) { alert('Enter server address'); return; }
            if (!url.startsWith('http')) url = 'http://' + url;
            serverUrl = url;
            
            fetch(`${serverUrl}/health`)
                .then(res => res.json())
                .then(() => {
                    statusEl.textContent = `‚úì Connected`;
                    statusEl.style.color = '#4ecca3';
                    startBtn.disabled = false;
                    voiceNavBtn.disabled = false;
                    setMapSource();
                })
                .catch(err => {
                    statusEl.textContent = `‚úó ${err.message}`;
                    statusEl.style.color = '#e74c3c';
                });
        });
        
        startBtn.addEventListener('click', async () => {
            try {
                if (!navigator.mediaDevices?.getUserMedia) {
                    alert('Camera not available. Use HTTPS or localhost.');
                    return;
                }
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { ideal: 'environment' }, width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                videoEl.srcObject = stream;
                await videoEl.play();
                statusEl.textContent = 'üì∑ Camera on ‚Äî say your destination';
                startBtn.disabled = true;
                stopBtn.disabled = false;
                announceBtn.disabled = false;
                videoContainer.classList.add('show-video');
                voicePrompt.textContent = 'Tap "Say destination" and say: "Take me to room 0010" (or type below). Tap Announce to hear what is in front of you.';
                connectWebSocket();
            } catch (err) {
                statusEl.textContent = `Camera: ${err.message}`;
                statusEl.style.color = '#e74c3c';
            }
        });
        
        stopBtn.addEventListener('click', () => {
            stopNavigation();
            if (guidanceInterval) { clearInterval(guidanceInterval); guidanceInterval = null; }
            isProcessing = false;
            if (ws) { ws.close(); ws = null; }
            if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
            statusEl.textContent = 'Stopped';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            announceBtn.disabled = true;
            mapContainer.classList.remove('visible');
        });
        
        function connectWebSocket() {
            const wsUrl = serverUrl.replace('http', 'ws') + '/ws/video';
            ws = new WebSocket(wsUrl);
            ws.onopen = () => { isProcessing = true; sendFrame(); };
            ws.onmessage = (ev) => {
                try {
                    const data = JSON.parse(ev.data);
                    if (data.error) return;
                    
                    if (data.frame_base64) {
                        processedFrame.src = 'data:image/jpeg;base64,' + data.frame_base64;
                        videoContainer.classList.remove('show-video');
                    }
                    if (data.objects) { lastDetections = data.objects; updateDetectionsList(data.objects); }
                    if (data.instruction) lastSpokenAnnouncement = data.instruction;
                    
                    // Ready for next frame
                    isProcessingWsFrame = false;
                    if (isProcessing) setTimeout(sendFrame, 150); // Control frame rate
                } catch (e) {
                    console.error("WS parse error", e);
                    isProcessingWsFrame = false;
                }
            };
            ws.onerror = () => { statusEl.textContent = 'WebSocket error'; statusEl.style.color = '#e74c3c'; isProcessingWsFrame = false; };
            ws.onclose = () => { if (isProcessing) setTimeout(connectWebSocket, 2000); };
        }
        
        function sendFrame() {
            if (isProcessingWsFrame || !videoEl.videoWidth || !ws || ws.readyState !== WebSocket.OPEN) return;
            
            isProcessingWsFrame = true;
            const canvas = document.createElement('canvas');
            // Optimization: Scale down to 240px width for absolute minimum latency
            const scale = 240 / videoEl.videoWidth;
            canvas.width = 240;
            canvas.height = videoEl.videoHeight * scale;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(blob => {
                if (!blob) { isProcessingWsFrame = false; return; }
                const reader = new FileReader();
                reader.onload = () => {
                    if (ws.readyState === WebSocket.OPEN) ws.send(reader.result.split(',')[1]);
                    else isProcessingWsFrame = false;
                };
                reader.readAsDataURL(blob);
            }, 'image/jpeg', 0.4); 
        }
        
        announceBtn.addEventListener('click', async () => {
            if (!videoEl.videoWidth || !serverUrl) return;
            announceBtn.disabled = true;
            statusEl.textContent = 'Analyzing scene‚Ä¶';
            try {
                const canvas = document.createElement('canvas');
                const scale = Math.min(1, 640 / videoEl.videoWidth);
                canvas.width = videoEl.videoWidth * scale;
                canvas.height = videoEl.videoHeight * scale;
                canvas.getContext('2d').drawImage(videoEl, 0, 0, canvas.width, canvas.height);
                const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.6));
                const form = new FormData();
                form.append('file', blob, 'scene.jpg');
                if (isNavigating && navDestination) form.append('navigation_context', 'User is heading to room ' + navDestination + '. Give verbal directions: say how many steps left or right if something is in the way.');
                
                const res = await fetch(serverUrl + '/analyze-and-announce', { method: 'POST', body: form });
                if (!res.ok) throw new Error('Server ' + res.status);
                
                const data = await res.json();
                const announcement = (data.announcement || "I couldn't analyze the scene.").trim();
                
                if (data.frame_base64) {
                    processedFrame.src = 'data:image/jpeg;base64,' + data.frame_base64;
                    videoContainer.classList.remove('show-video');
                }
                statusEl.textContent = 'Speaking‚Ä¶';
                await speakWithElevenLabs(announcement);
                lastSpokenAnnouncement = announcement;
            } catch (err) {
                console.error(err);
                statusEl.textContent = 'Error: ' + err.message;
                speak(lastSpokenAnnouncement || "Something went wrong. Check the server connection.");
            }
            announceBtn.disabled = false;
            if (isProcessing) statusEl.textContent = 'Camera on ‚Äî tap Announce again for directions';
        });
        
        function updateDetectionsList(objects) {
            if (!objects?.length) { detectionList.innerHTML = '<em>Path clear</em>'; return; }
            objects.sort((a, b) => (a.distance ?? 999) - (b.distance ?? 999));
            detectionList.innerHTML = objects.map(obj => {
                const d = obj.distance;
                let cls = 'distance-far', text = '‚Äî';
                if (d != null) {
                    if (d < 1) { cls = 'distance-close'; text = d.toFixed(1) + 'm ‚ö†'; }
                    else if (d < 2) { cls = 'distance-medium'; text = d.toFixed(1) + 'm'; }
                    else text = d.toFixed(1) + 'm';
                }
                return `<div class="detection-item"><span>${obj.label}</span><span class="${cls}">${text}</span></div>`;
            }).join('');
        }
        
        function speak(text) {
            if (!text) return;
            lastSpokenAnnouncement = text;
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 0.9;
            speechSynthesis.speak(u);
        }
        
        async function speakWithElevenLabs(text) {
            if (!text) return;
            try {
                const res = await fetch(serverUrl + '/announce', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                if (!res.ok) throw new Error(res.status);
                const blob = await res.blob();
                if (!blob || blob.size === 0) throw new Error('No audio');
                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                audio.onended = () => URL.revokeObjectURL(url);
                audio.onerror = () => { URL.revokeObjectURL(url); speak(text); };
                await audio.play();
            } catch (e) {
                console.warn('ElevenLabs fallback to TTS:', e);
                speak(text);
            }
        }
        
        voiceNavBtn.addEventListener('click', () => {
            if (isNavigating) { stopNavigation(); return; }
            startVoiceRecognition();
        });
        
        function startVoiceRecognition() {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SR) {
                manualEntry.classList.add('visible');
                statusEl.textContent = 'Voice not supported ‚Äî type room above';
                return;
            }
            recognition = new SR();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            recognition.onstart = () => {
                statusEl.textContent = 'üé§ Listening‚Ä¶';
                voiceNavBtn.textContent = 'üõë Cancel';
                voiceNavBtn.classList.add('active-nav');
            };
            recognition.onresult = (ev) => {
                const cmd = ev.results[0][0].transcript;
                statusEl.textContent = `Heard: "${cmd}"`;
                parseNavigationCommand(cmd);
            };
            recognition.onerror = () => {
                statusEl.textContent = 'Try again or type room number';
                manualEntry.classList.add('visible');
                resetVoiceBtn();
            };
            recognition.onend = () => resetVoiceBtn();
            recognition.start();
        }
        
        function resetVoiceBtn() {
            voiceNavBtn.textContent = 'üé§ Say destination';
            voiceNavBtn.classList.remove('active-nav');
        }
        
        document.getElementById('goBtn').addEventListener('click', () => {
            const dest = document.getElementById('manualDest').value.trim();
            if (dest) parseNavigationCommand('go to room ' + dest);
        });
        
        async function parseNavigationCommand(text) {
            statusEl.textContent = 'Finding route‚Ä¶';
            try {
                const res = await fetch(`${serverUrl}/navigate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, start_room: START_ROOM })
                });
                
                if (!res.ok) {
                   const errText = await res.text();
                   throw new Error(errText || 'Navigation failed');
                }
                
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                
                startNavigation(data);
            } catch (err) {
                console.error(err);
                statusEl.textContent = '‚ùå ' + (err.message || "Failed to find path");
                speak("I couldn't find a path to that room.");
                manualEntry.classList.add('visible');
            }
        }
        
        function startNavigation(data) {
            isNavigating = true;
            navPath = data.path || [];
            navDestination = data.destination || '?';
            
            navInfo.textContent = 'Destination: Room ' + navDestination;
            if (serverUrl && !mapImg.src) mapImg.src = serverUrl + '/static/floor_plans/basement.png';
            mapContainer.classList.add('visible');
            voiceNavBtn.textContent = 'üõë Stop nav';
            voiceNavBtn.classList.add('active-nav');
            statusEl.textContent = 'üß≠ Navigating to room ' + navDestination;
            
            speakWithElevenLabs(data.instruction || `Heading to room ${navDestination}. I will tell you when to turn and when to watch for obstacles. Tap Announce to hear what is in front of you.`);
            
            // Draw route on canvas
            setTimeout(() => drawPathOnMap(navPath), 500); // Wait for image load/layout
            
            startDynamicGuidance();
        }
        
        function stopNavigation() {
            isNavigating = false;
            // Clear canvas
            const ctx = routeCanvas.getContext('2d');
            ctx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);
            
            if (guidanceInterval) { clearInterval(guidanceInterval); guidanceInterval = null; }
            mapContainer.classList.remove('visible');
            resetVoiceBtn();
            statusEl.textContent = 'Navigation stopped';
            speak('Navigation stopped.');
        }
        
        function drawPathOnMap(path) {
            if (!path?.length) return;
            
            const ctx = routeCanvas.getContext('2d');
            // Match canvas size to displayed image size
            routeCanvas.width = mapImg.clientWidth;
            routeCanvas.height = mapImg.clientHeight;
            
            if (routeCanvas.width === 0) {
                // Image not loaded yet, retry
                setTimeout(() => drawPathOnMap(path), 500);
                return;
            }
            
            // Clear previous
            ctx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);
            
            // Assuming path coordinates match the intrinsic image size (1224x792)
            // We need to scale them to the displayed size
            const scaleX = routeCanvas.width / 1224;
            const scaleY = routeCanvas.height / 792;
            
            // Draw Path
            ctx.beginPath();
            ctx.moveTo(path[0].x * scaleX, path[0].y * scaleY);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x * scaleX, path[i].y * scaleY);
            }
            ctx.strokeStyle = '#007bff';
            ctx.lineWidth = 5;
            ctx.lineJoin = 'round';
            ctx.lineCap = 'round';
            ctx.stroke();
            
            // Draw Points
            path.forEach((p, i) => {
                const x = p.x * scaleX;
                const y = p.y * scaleY;
                
                ctx.beginPath();
                ctx.arc(x, y, i === 0 || i === path.length - 1 ? 8 : 4, 0, Math.PI * 2);
                ctx.fillStyle = i === 0 ? '#2ecc71' : (i === path.length - 1 ? '#e74c3c' : '#3498db');
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 2;
                ctx.stroke();
            });
        }
        
        function startDynamicGuidance() {
            if (guidanceInterval) return;
            const navContext = `User is heading to room ${navDestination}. Give one short instruction.`;
            
            guidanceInterval = setInterval(async () => {
                if (!isNavigating || !isProcessing || !videoEl.videoWidth) return;
                try {
                    const canvas = document.createElement('canvas');
                    const scale = Math.min(1, 640 / videoEl.videoWidth);
                    canvas.width = videoEl.videoWidth * scale;
                    canvas.height = videoEl.videoHeight * scale;
                    canvas.getContext('2d').drawImage(videoEl, 0, 0, canvas.width, canvas.height);
                    const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.6));
                    const form = new FormData();
                    form.append('file', blob, 'scene.jpg');
                    form.append('navigation_context', navContext);
                    
                    const res = await fetch(`${serverUrl}/analyze-and-announce`, { method: 'POST', body: form });
                    const data = await res.json();
                    const announcement = data.announcement;
                    if (announcement) {
                        statusEl.textContent = 'üó£Ô∏è ' + announcement.slice(0, 40) + '‚Ä¶';
                        await speakWithElevenLabs(announcement);
                    }
                } catch (e) { console.warn('Guidance:', e); }
            }, 8000); // Increased to 8s to avoid hitting rate limits
        }
        
        window.addEventListener('load', () => {
            const host = window.location.hostname;
            const port = window.location.port;
            if (host !== 'localhost' && host !== '127.0.0.1') serverUrlInput.value = host + ':8000';
            else serverUrlInput.value = 'localhost:8000';
            if (port === '8000' || window.location.origin.includes('8000')) {
                serverUrl = window.location.origin;
                setMapSource();
            }
        });
    </script>
</body>
</html>
