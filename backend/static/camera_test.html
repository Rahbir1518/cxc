<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Indoor Navigation - Voice & Map</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: white;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }
        
        header {
            background: #16213e;
            padding: 0.75rem 1rem;
            text-align: center;
        }
        
        h1 { font-size: 1.1rem; margin-bottom: 0.25rem; }
        
        #status { font-size: 0.85rem; color: #4ecca3; }
        
        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            gap: 0.75rem;
        }
        
        .server-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        
        .server-row input {
            flex: 1;
            padding: 0.6rem;
            border: none;
            border-radius: 8px;
            background: #0f0f23;
            color: white;
            font-size: 0.95rem;
        }
        
        .server-row button { padding: 0.6rem 1rem; }
        
        /* Map overlay - shown when navigating */
        #mapContainer {
            background: #0f0f23;
            border-radius: 12px;
            overflow: hidden;
            width: 100%;
            position: relative;
            display: none;
            border: 2px solid #4ecca3;
        }
        
        #mapContainer.visible { display: block; }
        
        #mapImg {
            width: 100%;
            display: block;
        }
        
        #routeCanvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
        }
        
        .nav-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            right: 8px;
            background: rgba(0,0,0,0.85);
            padding: 8px 10px;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #4ecca3;
            z-index: 5;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .nav-overlay .nav-icon {
            font-size: 1rem;
        }
        
        .nav-progress {
            position: absolute;
            bottom: 8px;
            left: 8px;
            right: 8px;
            background: rgba(0,0,0,0.85);
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 0.75rem;
            color: #a0a0c0;
            z-index: 5;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            background: #2a2a4e;
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #2ecc71, #4ecca3);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .legend {
            position: absolute;
            bottom: 36px;
            right: 8px;
            background: rgba(0,0,0,0.7);
            padding: 4px 8px;
            border-radius: 6px;
            font-size: 0.65rem;
            color: #ccc;
            display: flex;
            gap: 8px;
            z-index: 5;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 3px;
        }

        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .legend-line {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
        
        .video-container {
            position: relative;
            background: #0f0f23;
            border-radius: 12px;
            overflow: hidden;
            flex: 1;
            min-height: 220px;
        }
        
        #videoElement, #processedFrame {
            position: absolute;
            top: 0; left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
        }
        #videoElement { z-index: 0; }
        #processedFrame { z-index: 1; background: #000; }
        /* When show-video: only show raw video until first annotated frame arrives */
        .video-container.show-video #processedFrame { opacity: 0; pointer-events: none; }
        
        .voice-prompt {
            text-align: center;
            padding: 0.5rem;
            background: #16213e;
            border-radius: 10px;
            font-size: 0.9rem;
            color: #a0a0c0;
        }
        
        .voice-prompt strong { color: #4ecca3; }
        
        .controls {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        button {
            padding: 0.9rem 1.5rem;
            font-size: 0.95rem;
            font-weight: 600;
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        
        button:disabled { opacity: 0.5; cursor: not-allowed; }
        button:active:not(:disabled) { transform: scale(0.97); }
        
        #connectBtn { background: #4ecca3; color: #1a1a2e; }
        #startBtn { background: linear-gradient(135deg, #4ecca3, #38a3a5); color: #1a1a2e; }
        #stopBtn { background: #e74c3c; color: white; }
        #announceBtn { background: linear-gradient(135deg, #3498db, #2980b9); color: white; }
        #announceBtn:not(:disabled):hover { box-shadow: 0 0 12px rgba(52,152,219,0.5); }
        #voiceNavBtn {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
        }
        #voiceNavBtn.active-nav { box-shadow: 0 0 16px rgba(240, 147, 251, 0.6); }

        /* Speaking indicator on announce button */
        #announceBtn.speaking {
            animation: pulse-speak 1s ease-in-out infinite;
        }
        @keyframes pulse-speak {
            0%, 100% { box-shadow: 0 0 0 0 rgba(52,152,219,0.4); }
            50% { box-shadow: 0 0 20px 4px rgba(52,152,219,0.6); }
        }
        
        .manual-row {
            display: none;
            gap: 0.5rem;
            width: 100%;
        }
        .manual-row.visible { display: flex; }
        .manual-row input {
            flex: 1;
            padding: 0.6rem;
            border-radius: 8px;
            background: #2a2a4e;
            color: white;
            border: 1px solid #4ecca3;
        }
        
        .info-panel {
            background: #16213e;
            border-radius: 10px;
            padding: 0.75rem;
            max-height: 120px;
            overflow-y: auto;
        }
        .info-panel h2 { font-size: 0.9rem; margin-bottom: 0.35rem; color: #4ecca3; }
        #detectionList { font-size: 0.85rem; line-height: 1.5; }
        .detection-item { display: flex; justify-content: space-between; padding: 0.2rem 0; border-bottom: 1px solid #2a2a4e; }
        .distance-close { color: #e74c3c; }
        .distance-medium { color: #f39c12; }
        .distance-far { color: #4ecca3; }
    </style>
</head>
<body>
    <header>
        <h1>üß≠ Indoor Navigation</h1>
        <div id="status">Enter server address and connect</div>
    </header>
    
    <div class="container">
        <div class="server-row">
            <input type="text" id="serverUrl" placeholder="Server (e.g. 192.168.1.100:8000)" value="">
            <button id="connectBtn">Connect</button>
        </div>
        
        <div id="mapContainer">
            <div class="nav-overlay" id="navInfo">
                <span class="nav-icon">üß≠</span>
                <span id="navInfoText">Ready</span>
            </div>
            <img id="mapImg" alt="Floor Plan" />
            <canvas id="routeCanvas"></canvas>
            <div class="legend" id="mapLegend" style="display:none;">
                <div class="legend-item"><div class="legend-dot" style="background:#10b981;"></div> You</div>
                <div class="legend-item"><div class="legend-line" style="background:#2ecc71;"></div> Done</div>
                <div class="legend-item"><div class="legend-line" style="background:#3b82f6; border-style:dashed;"></div> Ahead</div>
                <div class="legend-item"><div class="legend-dot" style="background:#ef4444;"></div> End</div>
            </div>
            <div class="nav-progress" id="navProgress" style="display:none;">
                <span id="progressText">0%</span>
                <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
                <span id="etaText"></span>
            </div>
        </div>
        
        <p class="voice-prompt" style="margin-bottom:0;">Camera ‚Äî you'll hear what's in the way when you tap <strong>What's Ahead</strong>.</p>
        <div id="videoContainer" class="video-container">
            <video id="videoElement" autoplay playsinline></video>
            <img id="processedFrame" alt="Camera with object boxes when connected">
        </div>
        
        <div id="voicePrompt" class="voice-prompt">
            After connecting, tap <strong>Start</strong> then say: <strong>"Take me to room 0010"</strong>
        </div>
        
        <div class="controls">
            <button id="startBtn" disabled>üì∑ Start</button>
            <button id="stopBtn" disabled>‚èπ Stop</button>
            <button id="announceBtn" disabled>üîä What's Ahead</button>
            <button id="voiceNavBtn" disabled>üé§ Navigate</button>
        </div>
        
        <div id="manualEntry" class="manual-row">
            <input type="text" id="manualDest" placeholder="Room (e.g. 0010)">
            <button id="goBtn" style="padding: 0.6rem 1rem; background: #4ecca3; color: #1a1a2e; border-radius: 8px;">Go</button>
        </div>
        
        <div class="info-panel">
            <h2>Detected objects</h2>
            <div id="detectionList">Start camera to see detections.</div>
        </div>
    </div>
    
    <script>
        // ‚îÄ‚îÄ‚îÄ DOM REFS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const serverUrlInput = document.getElementById('serverUrl');
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const videoEl = document.getElementById('videoElement');
        const processedFrame = document.getElementById('processedFrame');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const voiceNavBtn = document.getElementById('voiceNavBtn');
        const mapContainer = document.getElementById('mapContainer');
        const mapImg = document.getElementById('mapImg');
        const routeCanvas = document.getElementById('routeCanvas');
        const navInfo = document.getElementById('navInfoText');
        const detectionList = document.getElementById('detectionList');
        const voicePrompt = document.getElementById('voicePrompt');
        const manualEntry = document.getElementById('manualEntry');
        const videoContainer = document.getElementById('videoContainer');
        const announceBtn = document.getElementById('announceBtn');
        const mapLegend = document.getElementById('mapLegend');
        const navProgress = document.getElementById('navProgress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const etaText = document.getElementById('etaText');
        
        const START_ROOM = '0020';
        const SVG_WIDTH = 1224;
        const SVG_HEIGHT = 792;
        
        // ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let serverUrl = '';
        let ws = null;
        let stream = null;
        let isProcessing = false;
        let isProcessingWsFrame = false;
        let lastDetections = [];
        let lastSpokenAnnouncement = '';
        
        let isNavigating = false;
        let navPath = [];
        let navDestination = null;
        let guidanceInterval = null;
        let recognition = null;

        // ‚îÄ‚îÄ‚îÄ AUDIO MANAGEMENT (fix overlapping voices) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let currentAudio = null;
        let isSpeakingEL = false;
        let speakQueue = null; // pending speak promise

        function stopAllAudio() {
            // Stop ElevenLabs audio
            if (currentAudio) {
                try {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    if (currentAudio._blobUrl) URL.revokeObjectURL(currentAudio._blobUrl);
                } catch(e) {}
                currentAudio = null;
            }
            // Stop browser TTS
            speechSynthesis.cancel();
            isSpeakingEL = false;
            announceBtn.classList.remove('speaking');
        }

        function speak(text) {
            if (!text) return;
            stopAllAudio();
            lastSpokenAnnouncement = text;
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 0.9;
            speechSynthesis.speak(u);
        }

        async function speakWithElevenLabs(text) {
            if (!text) return;

            // CRITICAL FIX: Stop any currently playing audio first
            stopAllAudio();

            isSpeakingEL = true;
            announceBtn.classList.add('speaking');

            try {
                const res = await fetch(serverUrl + '/announce', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                if (!res.ok) throw new Error(res.status);

                const blob = await res.blob();
                if (!blob || blob.size === 0) throw new Error('No audio');

                // Check if we were interrupted while waiting for the fetch
                if (!isSpeakingEL) return;

                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                audio._blobUrl = url; // track for cleanup

                return new Promise((resolve) => {
                    audio.onended = () => {
                        URL.revokeObjectURL(url);
                        currentAudio = null;
                        isSpeakingEL = false;
                        announceBtn.classList.remove('speaking');
                        resolve();
                    };
                    audio.onerror = () => {
                        URL.revokeObjectURL(url);
                        currentAudio = null;
                        isSpeakingEL = false;
                        announceBtn.classList.remove('speaking');
                        speak(text);
                        resolve();
                    };
                    currentAudio = audio;
                    audio.play().catch(() => {
                        currentAudio = null;
                        isSpeakingEL = false;
                        announceBtn.classList.remove('speaking');
                        speak(text);
                        resolve();
                    });
                });
            } catch (e) {
                console.warn('ElevenLabs fallback to TTS:', e);
                isSpeakingEL = false;
                announceBtn.classList.remove('speaking');
                speak(text);
            }
        }

        // ‚îÄ‚îÄ‚îÄ LIVE POSITION TRACKING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let userPosition = null;       // {x, y} current interpolated position
        let targetWaypointIdx = 1;     // next waypoint index
        let positionProgress = 0;      // 0..1 between waypoints
        let mapRenderRAF = null;       // animation frame id
        let navStartTime = null;       // when navigation started
        const WALK_SPEED = 0.002;      // progress per frame (~1.5m/s simulated)

        function startPositionTracking() {
            if (!navPath.length) return;
            userPosition = { x: navPath[0].x, y: navPath[0].y };
            targetWaypointIdx = Math.min(1, navPath.length - 1);
            positionProgress = 0;
            navStartTime = Date.now();
            mapLegend.style.display = 'flex';
            navProgress.style.display = 'flex';
            startMapRenderLoop();
        }

        function stopPositionTracking() {
            if (mapRenderRAF) {
                cancelAnimationFrame(mapRenderRAF);
                mapRenderRAF = null;
            }
            userPosition = null;
            targetWaypointIdx = 1;
            positionProgress = 0;
            mapLegend.style.display = 'none';
            navProgress.style.display = 'none';
        }

        function getTotalPathLength() {
            let total = 0;
            for (let i = 1; i < navPath.length; i++) {
                const dx = navPath[i].x - navPath[i-1].x;
                const dy = navPath[i].y - navPath[i-1].y;
                total += Math.sqrt(dx*dx + dy*dy);
            }
            return total;
        }

        function getTraversedLength() {
            let total = 0;
            for (let i = 1; i < targetWaypointIdx; i++) {
                const dx = navPath[i].x - navPath[i-1].x;
                const dy = navPath[i].y - navPath[i-1].y;
                total += Math.sqrt(dx*dx + dy*dy);
            }
            // Add current segment progress
            if (targetWaypointIdx < navPath.length && targetWaypointIdx > 0) {
                const dx = navPath[targetWaypointIdx].x - navPath[targetWaypointIdx-1].x;
                const dy = navPath[targetWaypointIdx].y - navPath[targetWaypointIdx-1].y;
                total += Math.sqrt(dx*dx + dy*dy) * positionProgress;
            }
            return total;
        }

        function startMapRenderLoop() {
            if (mapRenderRAF) return;

            function render() {
                if (!isNavigating) {
                    mapRenderRAF = null;
                    return;
                }

                // Advance simulated position along path
                if (targetWaypointIdx < navPath.length) {
                    // Variable speed based on segment length
                    const from = navPath[targetWaypointIdx - 1];
                    const to = navPath[targetWaypointIdx];
                    const segDx = to.x - from.x;
                    const segDy = to.y - from.y;
                    const segLen = Math.sqrt(segDx*segDx + segDy*segDy);
                    // Normalize speed so longer segments take proportionally longer
                    const speed = Math.max(0.001, 150 / segLen) * 0.016; // ~60fps adjusted

                    positionProgress += speed;

                    if (positionProgress >= 1) {
                        positionProgress = 0;
                        userPosition = { x: to.x, y: to.y };
                        targetWaypointIdx++;

                        if (targetWaypointIdx >= navPath.length) {
                            // Arrived!
                            userPosition = { x: navPath[navPath.length - 1].x, y: navPath[navPath.length - 1].y };
                        }
                    } else {
                        userPosition = {
                            x: from.x + segDx * positionProgress,
                            y: from.y + segDy * positionProgress,
                        };
                    }
                }

                // Update progress bar
                const totalLen = getTotalPathLength();
                const traversedLen = getTraversedLength();
                const pct = totalLen > 0 ? Math.min(100, (traversedLen / totalLen) * 100) : 0;
                progressFill.style.width = pct.toFixed(0) + '%';
                progressText.textContent = pct.toFixed(0) + '%';

                if (targetWaypointIdx >= navPath.length) {
                    etaText.textContent = 'Arrived!';
                    progressFill.style.width = '100%';
                    progressText.textContent = '100%';
                } else {
                    const remainPct = 100 - pct;
                    etaText.textContent = remainPct < 20 ? 'Almost there' : '';
                }

                drawMapWithPosition();
                mapRenderRAF = requestAnimationFrame(render);
            }

            mapRenderRAF = requestAnimationFrame(render);
        }

        function drawMapWithPosition() {
            if (!navPath?.length) return;

            const ctx = routeCanvas.getContext('2d');

            // Match canvas pixel size to displayed image size
            const w = mapImg.clientWidth;
            const h = mapImg.clientHeight;
            if (w === 0 || h === 0) return;

            // Set canvas internal resolution (only when changed)
            if (routeCanvas.width !== w || routeCanvas.height !== h) {
                routeCanvas.width = w;
                routeCanvas.height = h;
            }

            ctx.clearRect(0, 0, w, h);

            const scaleX = w / SVG_WIDTH;
            const scaleY = h / SVG_HEIGHT;

            const traversedIdx = targetWaypointIdx - 1;

            // ‚îÄ‚îÄ 1. Draw traversed path (green, solid) ‚îÄ‚îÄ
            if (traversedIdx >= 0 && userPosition) {
                ctx.beginPath();
                ctx.moveTo(navPath[0].x * scaleX, navPath[0].y * scaleY);
                for (let i = 1; i <= Math.min(traversedIdx, navPath.length - 1); i++) {
                    ctx.lineTo(navPath[i].x * scaleX, navPath[i].y * scaleY);
                }
                ctx.lineTo(userPosition.x * scaleX, userPosition.y * scaleY);
                ctx.strokeStyle = '#2ecc71';
                ctx.lineWidth = 6;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // ‚îÄ‚îÄ 2. Draw remaining path (blue, dashed, animated) ‚îÄ‚îÄ
            if (targetWaypointIdx < navPath.length) {
                ctx.beginPath();
                if (userPosition) {
                    ctx.moveTo(userPosition.x * scaleX, userPosition.y * scaleY);
                } else {
                    ctx.moveTo(navPath[0].x * scaleX, navPath[0].y * scaleY);
                }
                for (let i = targetWaypointIdx; i < navPath.length; i++) {
                    ctx.lineTo(navPath[i].x * scaleX, navPath[i].y * scaleY);
                }
                // Animated dash offset
                const dashOffset = (Date.now() / 50) % 30;
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 5;
                ctx.setLineDash([14, 8]);
                ctx.lineDashOffset = -dashOffset;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // ‚îÄ‚îÄ 3. Draw waypoints ‚îÄ‚îÄ
            navPath.forEach((p, i) => {
                const x = p.x * scaleX;
                const y = p.y * scaleY;
                const isEnd = i === navPath.length - 1;
                const isStart = i === 0;
                const isReached = i <= traversedIdx;

                // Only draw start and end prominently; middle ones are subtle
                if (isStart || isEnd) {
                    ctx.beginPath();
                    ctx.arc(x, y, isEnd ? 10 : 8, 0, Math.PI * 2);
                    ctx.fillStyle = isStart ? '#22c55e' : '#ef4444';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();

                    // Label
                    ctx.font = 'bold 11px sans-serif';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(isStart ? 'S' : 'E', x, y + 1);
                } else {
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = isReached ? '#2ecc71' : '#3b82f6';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            });

            // ‚îÄ‚îÄ 4. Draw user position (pulsing beacon) ‚îÄ‚îÄ
            if (userPosition) {
                const ux = userPosition.x * scaleX;
                const uy = userPosition.y * scaleY;
                const now = Date.now();
                const pulse = 1 + Math.sin(now / 250) * 0.35;

                // Outer ripple 1
                ctx.beginPath();
                ctx.arc(ux, uy, 22 * pulse, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(16, 185, 129, 0.12)';
                ctx.fill();

                // Outer ripple 2
                ctx.beginPath();
                ctx.arc(ux, uy, 14 * pulse, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(16, 185, 129, 0.25)';
                ctx.fill();

                // Inner solid dot
                ctx.beginPath();
                ctx.arc(ux, uy, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#10b981';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();

                // ‚îÄ‚îÄ 5. Direction arrow toward next waypoint ‚îÄ‚îÄ
                if (targetWaypointIdx < navPath.length) {
                    const target = navPath[targetWaypointIdx];
                    const dx = target.x - userPosition.x;
                    const dy = target.y - userPosition.y;
                    const angle = Math.atan2(dy * scaleY, dx * scaleX);
                    const arrowStart = 14;
                    const arrowLen = 22;

                    ctx.save();
                    ctx.translate(ux, uy);
                    ctx.rotate(angle);

                    // Arrow shaft
                    ctx.beginPath();
                    ctx.moveTo(arrowStart, 0);
                    ctx.lineTo(arrowStart + arrowLen, 0);
                    ctx.strokeStyle = '#4ecca3';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    // Arrow head
                    ctx.beginPath();
                    ctx.moveTo(arrowStart + arrowLen + 2, 0);
                    ctx.lineTo(arrowStart + arrowLen - 6, -5);
                    ctx.lineTo(arrowStart + arrowLen - 6, 5);
                    ctx.closePath();
                    ctx.fillStyle = '#4ecca3';
                    ctx.fill();

                    ctx.restore();
                }
            }
        }

        // ‚îÄ‚îÄ‚îÄ MAP SOURCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function setMapSource() {
            if (serverUrl && mapImg) {
                mapImg.src = serverUrl + '/static/floor_plans/basement.png';
                const ctx = routeCanvas.getContext('2d');
                ctx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);
            }
        }

        // ‚îÄ‚îÄ‚îÄ CONNECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        connectBtn.addEventListener('click', () => {
            let url = serverUrlInput.value.trim();
            if (!url) { alert('Enter server address'); return; }
            if (!url.startsWith('http')) url = 'http://' + url;
            serverUrl = url;
            
            fetch(`${serverUrl}/health`)
                .then(res => res.json())
                .then(() => {
                    statusEl.textContent = '‚úì Connected';
                    statusEl.style.color = '#4ecca3';
                    startBtn.disabled = false;
                    voiceNavBtn.disabled = false;
                    setMapSource();
                })
                .catch(err => {
                    statusEl.textContent = `‚úó ${err.message}`;
                    statusEl.style.color = '#e74c3c';
                });
        });

        // ‚îÄ‚îÄ‚îÄ CAMERA START/STOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        startBtn.addEventListener('click', async () => {
            try {
                if (!navigator.mediaDevices?.getUserMedia) {
                    alert('Camera not available. Use HTTPS or localhost.');
                    return;
                }
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { ideal: 'environment' }, width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                videoEl.srcObject = stream;
                await videoEl.play();
                statusEl.textContent = 'üì∑ Camera on ‚Äî tap Navigate to set a route';
                startBtn.disabled = true;
                stopBtn.disabled = false;
                announceBtn.disabled = false;
                videoContainer.classList.add('show-video');
                voicePrompt.textContent = 'Tap "Navigate" and say: "Take me to room 0010" (or type below). Tap "What\'s Ahead" to hear what is in front of you.';
                connectWebSocket();
            } catch (err) {
                statusEl.textContent = `Camera: ${err.message}`;
                statusEl.style.color = '#e74c3c';
            }
        });
        
        stopBtn.addEventListener('click', () => {
            stopNavigation();
            stopAllAudio();
            if (guidanceInterval) { clearInterval(guidanceInterval); guidanceInterval = null; }
            isProcessing = false;
            if (ws) { ws.close(); ws = null; }
            if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
            statusEl.textContent = 'Stopped';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            announceBtn.disabled = true;
            mapContainer.classList.remove('visible');
        });

        // ‚îÄ‚îÄ‚îÄ WEBSOCKET ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function connectWebSocket() {
            const wsUrl = serverUrl.replace('http', 'ws') + '/ws/video';
            ws = new WebSocket(wsUrl);
            ws.onopen = () => { isProcessing = true; sendFrame(); };
            ws.onmessage = (ev) => {
                try {
                    const data = JSON.parse(ev.data);
                    if (data.error) return;
                    
                    if (data.frame_base64) {
                        processedFrame.src = 'data:image/jpeg;base64,' + data.frame_base64;
                        videoContainer.classList.remove('show-video');
                    }
                    if (data.objects) { lastDetections = data.objects; updateDetectionsList(data.objects); }
                    if (data.instruction) lastSpokenAnnouncement = data.instruction;
                    
                    isProcessingWsFrame = false;
                    if (isProcessing) setTimeout(sendFrame, 150);
                } catch (e) {
                    console.error("WS parse error", e);
                    isProcessingWsFrame = false;
                }
            };
            ws.onerror = () => { statusEl.textContent = 'WebSocket error'; statusEl.style.color = '#e74c3c'; isProcessingWsFrame = false; };
            ws.onclose = () => { if (isProcessing) setTimeout(connectWebSocket, 2000); };
        }
        
        function sendFrame() {
            if (isProcessingWsFrame || !videoEl.videoWidth || !ws || ws.readyState !== WebSocket.OPEN) return;
            
            isProcessingWsFrame = true;
            const canvas = document.createElement('canvas');
            const scale = 240 / videoEl.videoWidth;
            canvas.width = 240;
            canvas.height = videoEl.videoHeight * scale;
            
            const ctx = canvas.getContext('2d');
            ctx.drawImage(videoEl, 0, 0, canvas.width, canvas.height);
            canvas.toBlob(blob => {
                if (!blob) { isProcessingWsFrame = false; return; }
                const reader = new FileReader();
                reader.onload = () => {
                    if (ws.readyState === WebSocket.OPEN) ws.send(reader.result.split(',')[1]);
                    else isProcessingWsFrame = false;
                };
                reader.readAsDataURL(blob);
            }, 'image/jpeg', 0.4);
        }

        // ‚îÄ‚îÄ‚îÄ ANNOUNCE (What's Ahead) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        announceBtn.addEventListener('click', async () => {
            if (!videoEl.videoWidth || !serverUrl) return;
            
            // If currently speaking, stop it
            if (isSpeakingEL) {
                stopAllAudio();
                statusEl.textContent = 'Stopped speaking';
                return;
            }

            announceBtn.disabled = true;
            statusEl.textContent = 'Analyzing scene‚Ä¶';
            try {
                const canvas = document.createElement('canvas');
                const scale = Math.min(1, 640 / videoEl.videoWidth);
                canvas.width = videoEl.videoWidth * scale;
                canvas.height = videoEl.videoHeight * scale;
                canvas.getContext('2d').drawImage(videoEl, 0, 0, canvas.width, canvas.height);
                const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.6));
                const form = new FormData();
                form.append('file', blob, 'scene.jpg');
                if (isNavigating && navDestination) form.append('navigation_context', 'User is heading to room ' + navDestination + '. Give verbal directions: say how many steps left or right if something is in the way.');
                
                const res = await fetch(serverUrl + '/analyze-and-announce', { method: 'POST', body: form });
                if (!res.ok) throw new Error('Server ' + res.status);
                
                const data = await res.json();
                const announcement = (data.announcement || "I couldn't analyze the scene.").trim();
                
                if (data.frame_base64) {
                    processedFrame.src = 'data:image/jpeg;base64,' + data.frame_base64;
                    videoContainer.classList.remove('show-video');
                }
                statusEl.textContent = 'üó£Ô∏è Speaking‚Ä¶';
                await speakWithElevenLabs(announcement);
                lastSpokenAnnouncement = announcement;
            } catch (err) {
                console.error(err);
                statusEl.textContent = 'Error: ' + err.message;
                speak(lastSpokenAnnouncement || "Something went wrong. Check the server connection.");
            }
            announceBtn.disabled = false;
            if (isProcessing) statusEl.textContent = isNavigating 
                ? 'üß≠ Navigating to room ' + navDestination 
                : 'Camera on ‚Äî tap What\'s Ahead for directions';
        });

        // ‚îÄ‚îÄ‚îÄ DETECTIONS LIST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function updateDetectionsList(objects) {
            if (!objects?.length) { detectionList.innerHTML = '<em>Path clear</em>'; return; }
            objects.sort((a, b) => (a.distance ?? 999) - (b.distance ?? 999));
            detectionList.innerHTML = objects.map(obj => {
                const d = obj.distance;
                let cls = 'distance-far', text = '‚Äî';
                if (d != null) {
                    if (d < 1) { cls = 'distance-close'; text = d.toFixed(1) + 'm ‚ö†'; }
                    else if (d < 2) { cls = 'distance-medium'; text = d.toFixed(1) + 'm'; }
                    else text = d.toFixed(1) + 'm';
                }
                return `<div class="detection-item"><span>${obj.label}</span><span class="${cls}">${text}</span></div>`;
            }).join('');
        }

        // ‚îÄ‚îÄ‚îÄ VOICE NAVIGATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        voiceNavBtn.addEventListener('click', () => {
            if (isNavigating) { stopNavigation(); return; }
            startVoiceRecognition();
        });
        
        function startVoiceRecognition() {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SR) {
                manualEntry.classList.add('visible');
                statusEl.textContent = 'Voice not supported ‚Äî type room above';
                return;
            }
            recognition = new SR();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            recognition.onstart = () => {
                statusEl.textContent = 'üé§ Listening‚Ä¶';
                voiceNavBtn.textContent = 'üõë Cancel';
                voiceNavBtn.classList.add('active-nav');
            };
            recognition.onresult = (ev) => {
                const cmd = ev.results[0][0].transcript;
                statusEl.textContent = `Heard: "${cmd}"`;
                parseNavigationCommand(cmd);
            };
            recognition.onerror = () => {
                statusEl.textContent = 'Try again or type room number';
                manualEntry.classList.add('visible');
                resetVoiceBtn();
            };
            recognition.onend = () => resetVoiceBtn();
            recognition.start();
        }
        
        function resetVoiceBtn() {
            voiceNavBtn.textContent = 'üé§ Navigate';
            voiceNavBtn.classList.remove('active-nav');
        }
        
        document.getElementById('goBtn').addEventListener('click', () => {
            const dest = document.getElementById('manualDest').value.trim();
            if (dest) parseNavigationCommand('go to room ' + dest);
        });

        // ‚îÄ‚îÄ‚îÄ NAVIGATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function parseNavigationCommand(text) {
            statusEl.textContent = 'Finding route‚Ä¶';
            try {
                const res = await fetch(`${serverUrl}/navigate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, start_room: START_ROOM })
                });
                
                if (!res.ok) {
                   const errText = await res.text();
                   throw new Error(errText || 'Navigation failed');
                }
                
                const data = await res.json();
                if (data.error) throw new Error(data.error);
                
                startNavigation(data);
            } catch (err) {
                console.error(err);
                statusEl.textContent = '‚ùå ' + (err.message || "Failed to find path");
                speak("I couldn't find a path to that room.");
                manualEntry.classList.add('visible');
            }
        }
        
        function startNavigation(data) {
            // Stop any previous navigation
            if (isNavigating) stopNavigation();

            isNavigating = true;
            navPath = data.path || [];
            navDestination = data.destination || '?';
            
            navInfo.textContent = 'Navigating to Room ' + navDestination;
            if (serverUrl && !mapImg.src) mapImg.src = serverUrl + '/static/floor_plans/basement.png';
            mapContainer.classList.add('visible');
            voiceNavBtn.textContent = 'üõë Stop';
            voiceNavBtn.classList.add('active-nav');
            statusEl.textContent = 'üß≠ Navigating to room ' + navDestination;
            
            // Speak navigation instruction (stops any current audio first)
            speakWithElevenLabs(data.instruction || `Heading to room ${navDestination}. I will tell you when to turn and when to watch for obstacles. Tap What's Ahead to hear what is in front of you.`);
            
            // Start live position tracking with slight delay for image load
            setTimeout(() => {
                startPositionTracking();
            }, 300);
            
            startDynamicGuidance();
        }
        
        function stopNavigation() {
            isNavigating = false;
            stopPositionTracking();
            stopAllAudio();
            
            // Clear canvas
            const ctx = routeCanvas.getContext('2d');
            ctx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);
            
            if (guidanceInterval) { clearInterval(guidanceInterval); guidanceInterval = null; }
            mapContainer.classList.remove('visible');
            resetVoiceBtn();
            statusEl.textContent = 'Navigation stopped';
        }

        // ‚îÄ‚îÄ‚îÄ DYNAMIC GUIDANCE (with overlap protection) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function startDynamicGuidance() {
            if (guidanceInterval) clearInterval(guidanceInterval);

            const navContext = `User is heading to room ${navDestination}. Give one short instruction.`;
            
            guidanceInterval = setInterval(async () => {
                // Don't overlap: skip if already speaking or not navigating
                if (!isNavigating || !isProcessing || !videoEl.videoWidth || isSpeakingEL) return;

                try {
                    const canvas = document.createElement('canvas');
                    const scale = Math.min(1, 640 / videoEl.videoWidth);
                    canvas.width = videoEl.videoWidth * scale;
                    canvas.height = videoEl.videoHeight * scale;
                    canvas.getContext('2d').drawImage(videoEl, 0, 0, canvas.width, canvas.height);
                    const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.6));
                    const form = new FormData();
                    form.append('file', blob, 'scene.jpg');
                    form.append('navigation_context', navContext);
                    
                    const res = await fetch(`${serverUrl}/analyze-and-announce`, { method: 'POST', body: form });
                    const data = await res.json();
                    const announcement = data.announcement;
                    if (announcement && !isSpeakingEL) {
                        statusEl.textContent = 'üó£Ô∏è ' + announcement.slice(0, 50) + '‚Ä¶';
                        await speakWithElevenLabs(announcement);
                    }
                } catch (e) { console.warn('Guidance:', e); }
            }, 10000); // 10s interval, plus skip if still speaking
        }

        // ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        window.addEventListener('load', () => {
            const host = window.location.hostname;
            const port = window.location.port;
            if (host !== 'localhost' && host !== '127.0.0.1') serverUrlInput.value = host + ':8000';
            else serverUrlInput.value = 'localhost:8000';
            if (port === '8000' || window.location.origin.includes('8000')) {
                serverUrl = window.location.origin;
                setMapSource();
            }
        });
    </script>
</body>
</html>
