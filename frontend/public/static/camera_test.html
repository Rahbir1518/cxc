<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DWS ‚Äî Indoor Navigation</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        :root {
            --smoke-50: #f2f4f3;
            --smoke-100: #e5e9e7;
            --smoke-200: #d5dbd8;
            --smoke-300: #bfc8c3;
            --smoke-400: #a3aea8;
            --smoke-500: #87948d;
            --smoke-600: #6b7872;
            --smoke-700: #4f5c57;
            --smoke-800: #33403c;
            --smoke-900: #1a2420;

            --color-primary-400: #c8d5cf;
            --color-primary-500: #bfc8c3;
            --color-primary-600: #9aada5;

            --color-bg-primary: #0a0e0c;
            --color-bg-secondary: #101614;
            --color-bg-card: #121a17;
            --color-bg-tertiary: #1a2420;
            --color-bg-hover: #1e2a26;

            --color-text-primary: #f2f4f3;
            --color-text-secondary: #bfc8c3;
            --color-text-muted: #87948d;

            --color-border: rgba(191, 200, 195, 0.1);
            --color-border-hover: rgba(191, 200, 195, 0.3);

            --gradient-smoke: linear-gradient(135deg, #d5dbd8 0%, #bfc8c3 100%);
            --gradient-primary: linear-gradient(135deg, #bfc8c3 0%, #9aada5 50%, #7a9189 100%);

            --font-sans: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: 'JetBrains Mono', 'Fira Code', monospace;

            --radius-sm: 0.5rem;
            --radius-md: 0.75rem;
            --radius-lg: 1rem;

            --transition-fast: 150ms ease;
            --transition-base: 250ms ease;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: var(--font-sans);
            background: var(--color-bg-primary);
            color: var(--color-text-primary);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            -webkit-font-smoothing: antialiased;
        }

        header {
            background: var(--color-bg-secondary);
            padding: 0.75rem 1rem;
            text-align: center;
            border-bottom: 1px solid var(--color-border);
        }

        .header-brand {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .logo-icon {
            width: 28px; height: 28px;
            background: var(--gradient-smoke);
            border-radius: var(--radius-sm);
            display: flex; align-items: center; justify-content: center;
            position: relative; overflow: hidden;
            font-size: 0.7rem;
        }
        .logo-icon::before {
            content: ''; position: absolute; inset: 2px;
            background: var(--color-bg-primary);
            border-radius: calc(var(--radius-sm) - 2px);
        }
        .logo-icon span { position: relative; z-index: 1; }

        h1 {
            font-size: 1.1rem;
            font-weight: 700;
            letter-spacing: -0.02em;
            background: linear-gradient(135deg, #fff 0%, var(--color-primary-400) 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        #status {
            font-size: 0.8rem;
            color: var(--color-primary-400);
            font-family: var(--font-mono);
            font-weight: 500;
        }

        .container {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.75rem;
            gap: 0.75rem;
        }

        .server-row {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }

        .server-row input {
            flex: 1;
            padding: 0.6rem 0.75rem;
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            background: var(--color-bg-card);
            color: var(--color-text-primary);
            font-size: 0.9rem;
            font-family: var(--font-mono);
            transition: border-color var(--transition-fast);
        }

        .server-row input:focus {
            outline: none;
            border-color: var(--color-border-hover);
        }

        /* Map overlay */
        #mapContainer {
            background: var(--color-bg-card);
            border-radius: var(--radius-lg);
            overflow: hidden;
            width: 100%;
            position: relative;
            display: none;
            border: 1px solid var(--color-border);
        }

        #mapContainer.visible { display: block; }

        #mapImg { width: 100%; display: block; }

        #routeCanvas {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none;
        }

        .nav-overlay {
            position: absolute;
            top: 8px; left: 8px; right: 8px;
            background: rgba(10,14,12,0.9);
            backdrop-filter: blur(10px);
            padding: 8px 12px;
            border-radius: var(--radius-md);
            font-size: 0.8rem;
            color: var(--color-primary-400);
            z-index: 5;
            display: flex;
            align-items: center;
            gap: 6px;
            border: 1px solid var(--color-border);
        }

        .nav-overlay .nav-icon { font-size: 1rem; }

        .nav-progress {
            position: absolute;
            bottom: 8px; left: 8px; right: 8px;
            background: rgba(10,14,12,0.9);
            backdrop-filter: blur(10px);
            padding: 6px 12px;
            border-radius: var(--radius-md);
            font-size: 0.7rem;
            color: var(--color-text-muted);
            z-index: 5;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid var(--color-border);
        }

        .progress-bar {
            flex: 1;
            height: 4px;
            background: var(--color-bg-tertiary);
            border-radius: 2px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: var(--gradient-smoke);
            border-radius: 2px;
            transition: width 0.3s ease;
        }

        .legend {
            position: absolute;
            bottom: 36px; right: 8px;
            background: rgba(10,14,12,0.85);
            backdrop-filter: blur(10px);
            padding: 4px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.6rem;
            color: var(--color-text-muted);
            display: flex;
            gap: 8px;
            z-index: 5;
            border: 1px solid var(--color-border);
        }

        .legend-item { display: flex; align-items: center; gap: 3px; }
        .legend-dot { width: 8px; height: 8px; border-radius: 50%; }
        .legend-line { width: 16px; height: 3px; border-radius: 2px; }

        .video-container {
            position: relative;
            background: var(--color-bg-card);
            border-radius: var(--radius-lg);
            overflow: hidden;
            flex: 1;
            min-height: 220px;
            border: 1px solid var(--color-border);
        }

        #videoElement, #processedFrame {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
        }
        #videoElement { z-index: 0; }
        #processedFrame { z-index: 1; background: #000; }
        .video-container.show-video #processedFrame { opacity: 0; pointer-events: none; }

        .voice-prompt {
            text-align: center;
            padding: 0.6rem 0.75rem;
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-md);
            font-size: 0.85rem;
            color: var(--color-text-muted);
        }

        .voice-prompt strong { color: var(--color-primary-400); }

        .controls {
            display: flex;
            gap: 0.6rem;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 0.75rem 1.25rem;
            font-size: 0.875rem;
            font-weight: 600;
            font-family: var(--font-sans);
            border: none;
            border-radius: 50px;
            cursor: pointer;
            transition: all var(--transition-fast);
            letter-spacing: -0.01em;
        }

        button:disabled { opacity: 0.4; cursor: not-allowed; }
        button:active:not(:disabled) { transform: scale(0.97); }

        #connectBtn {
            background: var(--gradient-smoke);
            color: var(--color-bg-primary);
        }
        #connectBtn:hover:not(:disabled) {
            box-shadow: 0 0 20px rgba(191,200,195,0.25);
        }

        #startBtn {
            background: var(--gradient-smoke);
            color: var(--color-bg-primary);
        }
        #startBtn:hover:not(:disabled) {
            box-shadow: 0 0 20px rgba(191,200,195,0.25);
        }

        #stopBtn {
            background: rgba(252,165,165,0.15);
            color: #fca5a5;
            border: 1px solid rgba(252,165,165,0.2);
        }
        #stopBtn:hover:not(:disabled) {
            background: rgba(252,165,165,0.25);
        }

        #announceBtn {
            background: rgba(191,200,195,0.1);
            color: var(--color-primary-400);
            border: 1px solid var(--color-border);
        }
        #announceBtn:not(:disabled):hover {
            border-color: var(--color-border-hover);
            box-shadow: 0 0 12px rgba(191,200,195,0.15);
        }

        #voiceNavBtn {
            background: rgba(191,200,195,0.1);
            color: var(--color-primary-400);
            border: 1px solid var(--color-border);
        }
        #voiceNavBtn:hover:not(:disabled) {
            border-color: var(--color-border-hover);
        }
        #voiceNavBtn.active-nav {
            background: rgba(252,165,165,0.15);
            color: #fca5a5;
            border-color: rgba(252,165,165,0.2);
        }

        /* Speaking indicator */
        #announceBtn.speaking {
            animation: pulse-speak 1s ease-in-out infinite;
        }
        @keyframes pulse-speak {
            0%, 100% { box-shadow: 0 0 0 0 rgba(191,200,195,0.2); }
            50% { box-shadow: 0 0 20px 4px rgba(191,200,195,0.4); }
        }

        .manual-row {
            display: none;
            gap: 0.5rem;
            width: 100%;
        }
        .manual-row.visible { display: flex; }
        .manual-row input {
            flex: 1;
            padding: 0.6rem 0.75rem;
            border-radius: var(--radius-md);
            background: var(--color-bg-card);
            color: var(--color-text-primary);
            border: 1px solid var(--color-border);
            font-family: var(--font-mono);
            font-size: 0.875rem;
        }
        .manual-row input:focus {
            outline: none;
            border-color: var(--color-border-hover);
        }

        .info-panel {
            background: var(--color-bg-card);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-lg);
            padding: 0.75rem;
            max-height: 150px;
            overflow-y: auto;
        }
        .info-panel h2 {
            font-size: 0.8rem;
            margin-bottom: 0.4rem;
            color: var(--color-primary-400);
            font-weight: 600;
            letter-spacing: -0.01em;
        }
        #detectionList {
            font-size: 0.8rem;
            line-height: 1.5;
        }
        .detection-item {
            display: flex;
            justify-content: space-between;
            padding: 0.25rem 0;
            border-bottom: 1px solid var(--color-border);
        }
        .detection-item:last-child { border-bottom: none; }
        .distance-close { color: #fca5a5; }
        .distance-medium { color: #fde047; }
        .distance-far { color: #86efac; }

        /* Scrollbar */
        ::-webkit-scrollbar { width: 6px; }
        ::-webkit-scrollbar-track { background: var(--color-bg-primary); }
        ::-webkit-scrollbar-thumb { background: var(--color-bg-tertiary); border-radius: 999px; }
        ::-webkit-scrollbar-thumb:hover { background: var(--color-border-hover); }
    </style>
</head>
<body>
    <header>
        <div class="header-brand">
            <div class="logo-icon"><span>üëÅ</span></div>
            <h1>DWS ‚Äî Indoor Navigation</h1>
        </div>
        <div id="status">Enter server address and connect</div>
    </header>

    <div class="container">
        <div class="server-row">
            <input type="text" id="serverUrl" placeholder="Server (e.g. 192.168.1.100:8000)" value="">
            <button id="connectBtn">Connect</button>
        </div>

        <div id="mapContainer">
            <div class="nav-overlay" id="navInfo">
                <span class="nav-icon">üß≠</span>
                <span id="navInfoText">Ready</span>
            </div>
            <img id="mapImg" alt="Floor Plan" />
            <canvas id="routeCanvas"></canvas>
            <div class="legend" id="mapLegend" style="display:none;">
                <div class="legend-item"><div class="legend-dot" style="background:#86efac;"></div> You</div>
                <div class="legend-item"><div class="legend-line" style="background:#86efac;"></div> Done</div>
                <div class="legend-item"><div class="legend-line" style="background:#9aada5; border-style:dashed;"></div> Ahead</div>
                <div class="legend-item"><div class="legend-dot" style="background:#fca5a5;"></div> End</div>
            </div>
            <div class="nav-progress" id="navProgress" style="display:none;">
                <span id="progressText">0%</span>
                <div class="progress-bar"><div class="progress-fill" id="progressFill" style="width:0%"></div></div>
                <span id="etaText"></span>
            </div>
        </div>

        <p class="voice-prompt" style="margin-bottom:0;">Camera active ‚Äî tap <strong>Navigate</strong> for step-by-step guidance every 3 seconds.</p>
        <div id="videoContainer" class="video-container">
            <video id="videoElement" autoplay playsinline></video>
            <img id="processedFrame" alt="Camera with object boxes when connected">
        </div>

        <div id="voicePrompt" class="voice-prompt">
            After connecting, tap <strong>Start</strong> then say: <strong>"Take me to room 0010"</strong>
        </div>

        <div class="controls">
            <button id="startBtn" disabled>üì∑ Start</button>
            <button id="stopBtn" disabled>‚èπ Stop</button>
            <button id="announceBtn" disabled style="display:none;">üîä What's Ahead</button>
            <button id="voiceNavBtn" disabled>üé§ Navigate</button>
        </div>

        <div id="manualEntry" class="manual-row">
            <input type="text" id="manualDest" placeholder="Room (e.g. 0010)">
            <button id="goBtn" style="padding: 0.6rem 1rem; background: var(--gradient-smoke); color: var(--color-bg-primary); border-radius: var(--radius-md);">Go</button>
        </div>

        <div class="info-panel" id="braillePanel" style="display:none; border-color: rgba(139,92,246,0.3);">
            <h2 style="color:#a78bfa;">‚†ø Braille Detected</h2>
            <div id="brailleText" style="font-size:1rem; color:#e9d5ff; font-weight:500;"></div>
        </div>

        <div class="info-panel">
            <h2>Detected objects</h2>
            <div id="detectionList">Start camera to see detections.</div>
        </div>
    </div>

    <script>
        // ‚îÄ‚îÄ‚îÄ DOM REFS ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        const serverUrlInput = document.getElementById('serverUrl');
        const connectBtn = document.getElementById('connectBtn');
        const statusEl = document.getElementById('status');
        const videoEl = document.getElementById('videoElement');
        const processedFrame = document.getElementById('processedFrame');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const voiceNavBtn = document.getElementById('voiceNavBtn');
        const mapContainer = document.getElementById('mapContainer');
        const mapImg = document.getElementById('mapImg');
        const routeCanvas = document.getElementById('routeCanvas');
        const navInfo = document.getElementById('navInfoText');
        const detectionList = document.getElementById('detectionList');
        const voicePrompt = document.getElementById('voicePrompt');
        const manualEntry = document.getElementById('manualEntry');
        const videoContainer = document.getElementById('videoContainer');
        const announceBtn = document.getElementById('announceBtn');
        const braillePanel = document.getElementById('braillePanel');
        const brailleTextEl = document.getElementById('brailleText');
        const mapLegend = document.getElementById('mapLegend');
        const navProgress = document.getElementById('navProgress');
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const etaText = document.getElementById('etaText');

        const START_ROOM = '0020';
        const SVG_WIDTH = 1224;
        const SVG_HEIGHT = 792;

        // ‚îÄ‚îÄ‚îÄ STATE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let serverUrl = '';
        let ws = null;
        let stream = null;
        let isProcessing = false;
        let isProcessingWsFrame = false;
        let lastDetections = [];
        let lastSpokenAnnouncement = '';

        let isNavigating = false;
        let navPath = [];
        let navDestination = null;
        let guidanceInterval = null;
        let recognition = null;

        // ‚îÄ‚îÄ‚îÄ AUDIO MANAGEMENT (fix overlapping voices) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let currentAudio = null;
        let isSpeakingEL = false;
        let speakQueue = null;

        function stopAllAudio() {
            if (currentAudio) {
                try {
                    currentAudio.pause();
                    currentAudio.currentTime = 0;
                    if (currentAudio._blobUrl) URL.revokeObjectURL(currentAudio._blobUrl);
                } catch(e) {}
                currentAudio = null;
            }
            speechSynthesis.cancel();
            isSpeakingEL = false;
            announceBtn.classList.remove('speaking');
        }

        function speak(text) {
            if (!text) return;
            stopAllAudio();
            lastSpokenAnnouncement = text;
            const u = new SpeechSynthesisUtterance(text);
            u.rate = 0.9;
            speechSynthesis.speak(u);
        }

        async function speakWithElevenLabs(text) {
            if (!text) return;
            stopAllAudio();
            isSpeakingEL = true;
            announceBtn.classList.add('speaking');

            try {
                const res = await fetch(serverUrl + '/announce', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text })
                });
                if (!res.ok) throw new Error(res.status);

                const blob = await res.blob();
                if (!blob || blob.size === 0) throw new Error('No audio');

                if (!isSpeakingEL) return;

                const url = URL.createObjectURL(blob);
                const audio = new Audio(url);
                audio._blobUrl = url;

                return new Promise((resolve) => {
                    audio.onended = () => {
                        URL.revokeObjectURL(url);
                        currentAudio = null;
                        isSpeakingEL = false;
                        announceBtn.classList.remove('speaking');
                        resolve();
                    };
                    audio.onerror = () => {
                        URL.revokeObjectURL(url);
                        currentAudio = null;
                        isSpeakingEL = false;
                        announceBtn.classList.remove('speaking');
                        speak(text);
                        resolve();
                    };
                    currentAudio = audio;
                    audio.play().catch(() => {
                        currentAudio = null;
                        isSpeakingEL = false;
                        announceBtn.classList.remove('speaking');
                        speak(text);
                        resolve();
                    });
                });
            } catch (e) {
                console.warn('ElevenLabs fallback to TTS:', e);
                isSpeakingEL = false;
                announceBtn.classList.remove('speaking');
                speak(text);
            }
        }

        // ‚îÄ‚îÄ‚îÄ LIVE POSITION TRACKING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let userPosition = null;
        let targetWaypointIdx = 1;
        let positionProgress = 0;
        let mapRenderRAF = null;
        let navStartTime = null;
        const WALK_SPEED = 0.002;

        function startPositionTracking() {
            if (!navPath.length) return;
            userPosition = { x: navPath[0].x, y: navPath[0].y };
            targetWaypointIdx = Math.min(1, navPath.length - 1);
            positionProgress = 0;
            navStartTime = Date.now();
            mapLegend.style.display = 'flex';
            navProgress.style.display = 'flex';
            startMapRenderLoop();
        }

        function stopPositionTracking() {
            if (mapRenderRAF) {
                cancelAnimationFrame(mapRenderRAF);
                mapRenderRAF = null;
            }
            userPosition = null;
            targetWaypointIdx = 1;
            positionProgress = 0;
            mapLegend.style.display = 'none';
            navProgress.style.display = 'none';
        }

        function getTotalPathLength() {
            let total = 0;
            for (let i = 1; i < navPath.length; i++) {
                const dx = navPath[i].x - navPath[i-1].x;
                const dy = navPath[i].y - navPath[i-1].y;
                total += Math.sqrt(dx*dx + dy*dy);
            }
            return total;
        }

        function getTraversedLength() {
            let total = 0;
            for (let i = 1; i < targetWaypointIdx; i++) {
                const dx = navPath[i].x - navPath[i-1].x;
                const dy = navPath[i].y - navPath[i-1].y;
                total += Math.sqrt(dx*dx + dy*dy);
            }
            if (targetWaypointIdx < navPath.length && targetWaypointIdx > 0) {
                const dx = navPath[targetWaypointIdx].x - navPath[targetWaypointIdx-1].x;
                const dy = navPath[targetWaypointIdx].y - navPath[targetWaypointIdx-1].y;
                total += Math.sqrt(dx*dx + dy*dy) * positionProgress;
            }
            return total;
        }

        function startMapRenderLoop() {
            if (mapRenderRAF) return;

            function render() {
                if (!isNavigating) {
                    mapRenderRAF = null;
                    return;
                }

                if (targetWaypointIdx < navPath.length) {
                    const from = navPath[targetWaypointIdx - 1];
                    const to = navPath[targetWaypointIdx];
                    const segDx = to.x - from.x;
                    const segDy = to.y - from.y;
                    const segLen = Math.sqrt(segDx*segDx + segDy*segDy);
                    const speed = Math.max(0.001, 150 / segLen) * 0.016;

                    positionProgress += speed;

                    if (positionProgress >= 1) {
                        positionProgress = 0;
                        userPosition = { x: to.x, y: to.y };
                        targetWaypointIdx++;

                        if (targetWaypointIdx >= navPath.length) {
                            userPosition = { x: navPath[navPath.length - 1].x, y: navPath[navPath.length - 1].y };
                        }
                    } else {
                        userPosition = {
                            x: from.x + segDx * positionProgress,
                            y: from.y + segDy * positionProgress,
                        };
                    }
                }

                const totalLen = getTotalPathLength();
                const traversedLen = getTraversedLength();
                const pct = totalLen > 0 ? Math.min(100, (traversedLen / totalLen) * 100) : 0;
                progressFill.style.width = pct.toFixed(0) + '%';
                progressText.textContent = pct.toFixed(0) + '%';

                if (targetWaypointIdx >= navPath.length) {
                    etaText.textContent = 'Arrived!';
                    progressFill.style.width = '100%';
                    progressText.textContent = '100%';
                } else {
                    const remainPct = 100 - pct;
                    etaText.textContent = remainPct < 20 ? 'Almost there' : '';
                }

                drawMapWithPosition();
                mapRenderRAF = requestAnimationFrame(render);
            }

            mapRenderRAF = requestAnimationFrame(render);
        }

        function drawMapWithPosition() {
            if (!navPath?.length) return;

            const ctx = routeCanvas.getContext('2d');
            const w = mapImg.clientWidth;
            const h = mapImg.clientHeight;
            if (w === 0 || h === 0) return;

            if (routeCanvas.width !== w || routeCanvas.height !== h) {
                routeCanvas.width = w;
                routeCanvas.height = h;
            }

            ctx.clearRect(0, 0, w, h);

            const scaleX = w / SVG_WIDTH;
            const scaleY = h / SVG_HEIGHT;
            const traversedIdx = targetWaypointIdx - 1;

            // Traversed path (green, solid)
            if (traversedIdx >= 0 && userPosition) {
                ctx.beginPath();
                ctx.moveTo(navPath[0].x * scaleX, navPath[0].y * scaleY);
                for (let i = 1; i <= Math.min(traversedIdx, navPath.length - 1); i++) {
                    ctx.lineTo(navPath[i].x * scaleX, navPath[i].y * scaleY);
                }
                ctx.lineTo(userPosition.x * scaleX, userPosition.y * scaleY);
                ctx.strokeStyle = '#86efac';
                ctx.lineWidth = 6;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // Remaining path (sage, dashed, animated)
            if (targetWaypointIdx < navPath.length) {
                ctx.beginPath();
                if (userPosition) {
                    ctx.moveTo(userPosition.x * scaleX, userPosition.y * scaleY);
                } else {
                    ctx.moveTo(navPath[0].x * scaleX, navPath[0].y * scaleY);
                }
                for (let i = targetWaypointIdx; i < navPath.length; i++) {
                    ctx.lineTo(navPath[i].x * scaleX, navPath[i].y * scaleY);
                }
                const dashOffset = (Date.now() / 50) % 30;
                ctx.strokeStyle = '#9aada5';
                ctx.lineWidth = 5;
                ctx.setLineDash([14, 8]);
                ctx.lineDashOffset = -dashOffset;
                ctx.lineJoin = 'round';
                ctx.lineCap = 'round';
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // Waypoints
            navPath.forEach((p, i) => {
                const x = p.x * scaleX;
                const y = p.y * scaleY;
                const isEnd = i === navPath.length - 1;
                const isStart = i === 0;
                const isReached = i <= traversedIdx;

                if (isStart || isEnd) {
                    ctx.beginPath();
                    ctx.arc(x, y, isEnd ? 10 : 8, 0, Math.PI * 2);
                    ctx.fillStyle = isStart ? '#86efac' : '#fca5a5';
                    ctx.fill();
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2.5;
                    ctx.stroke();

                    ctx.font = 'bold 11px Inter, sans-serif';
                    ctx.fillStyle = 'white';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(isStart ? 'S' : 'E', x, y + 1);
                } else {
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, Math.PI * 2);
                    ctx.fillStyle = isReached ? '#86efac' : '#9aada5';
                    ctx.fill();
                    ctx.strokeStyle = 'rgba(255,255,255,0.6)';
                    ctx.lineWidth = 1.5;
                    ctx.stroke();
                }
            });

            // User position (pulsing beacon)
            if (userPosition) {
                const ux = userPosition.x * scaleX;
                const uy = userPosition.y * scaleY;
                const now = Date.now();
                const pulse = 1 + Math.sin(now / 250) * 0.35;

                ctx.beginPath();
                ctx.arc(ux, uy, 22 * pulse, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(134, 239, 172, 0.12)';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(ux, uy, 14 * pulse, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(134, 239, 172, 0.25)';
                ctx.fill();

                ctx.beginPath();
                ctx.arc(ux, uy, 8, 0, Math.PI * 2);
                ctx.fillStyle = '#86efac';
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Direction arrow
                if (targetWaypointIdx < navPath.length) {
                    const target = navPath[targetWaypointIdx];
                    const dx = target.x - userPosition.x;
                    const dy = target.y - userPosition.y;
                    const angle = Math.atan2(dy * scaleY, dx * scaleX);
                    const arrowStart = 14;
                    const arrowLen = 22;

                    ctx.save();
                    ctx.translate(ux, uy);
                    ctx.rotate(angle);

                    ctx.beginPath();
                    ctx.moveTo(arrowStart, 0);
                    ctx.lineTo(arrowStart + arrowLen, 0);
                    ctx.strokeStyle = '#bfc8c3';
                    ctx.lineWidth = 3;
                    ctx.lineCap = 'round';
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(arrowStart + arrowLen + 2, 0);
                    ctx.lineTo(arrowStart + arrowLen - 6, -5);
                    ctx.lineTo(arrowStart + arrowLen - 6, 5);
                    ctx.closePath();
                    ctx.fillStyle = '#bfc8c3';
                    ctx.fill();

                    ctx.restore();
                }
            }
        }

        // ‚îÄ‚îÄ‚îÄ MAP SOURCE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function setMapSource() {
            if (serverUrl && mapImg) {
                mapImg.src = serverUrl + '/static/floor_plans/basement.png';
                const ctx = routeCanvas.getContext('2d');
                ctx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);
            }
        }

        // ‚îÄ‚îÄ‚îÄ CONNECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        connectBtn.addEventListener('click', () => {
            let url = serverUrlInput.value.trim();
            if (!url) { alert('Enter server address'); return; }
            if (!url.startsWith('http')) url = 'http://' + url;
            serverUrl = url;

            fetch(`${serverUrl}/health`)
                .then(res => res.json())
                .then(() => {
                    statusEl.textContent = '‚úì Connected';
                    statusEl.style.color = '#86efac';
                    startBtn.disabled = false;
                    voiceNavBtn.disabled = false;
                    setMapSource();
                })
                .catch(err => {
                    statusEl.textContent = `‚úó ${err.message}`;
                    statusEl.style.color = '#fca5a5';
                });
        });

        // ‚îÄ‚îÄ‚îÄ CAMERA START/STOP ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        startBtn.addEventListener('click', async () => {
            try {
                if (!navigator.mediaDevices?.getUserMedia) {
                    alert('Camera not available. Use HTTPS or localhost.');
                    return;
                }
                stream = await navigator.mediaDevices.getUserMedia({
                    video: { facingMode: { ideal: 'environment' }, width: { ideal: 640 }, height: { ideal: 480 } },
                    audio: false
                });
                videoEl.srcObject = stream;
                await videoEl.play();
                statusEl.textContent = 'üì∑ Camera on ‚Äî tap Navigate to set a route';
                startBtn.disabled = true;
                stopBtn.disabled = false;
                announceBtn.disabled = false;
                videoContainer.classList.add('show-video');
                voicePrompt.textContent = 'Tap "Navigate" and say: "Take me to room 0010" (or type below). I\'ll guide you every 3 seconds with step-by-step directions.';
                connectWebSocket();
            } catch (err) {
                statusEl.textContent = `Camera: ${err.message}`;
                statusEl.style.color = '#fca5a5';
            }
        });

        stopBtn.addEventListener('click', () => {
            stopNavigation();
            stopAllAudio();
            stopSendLoop();
            if (guidanceInterval) { clearInterval(guidanceInterval); guidanceInterval = null; }
            isProcessing = false;
            awaitingResponse = false;
            if (ws) { ws.close(); ws = null; }
            if (stream) { stream.getTracks().forEach(t => t.stop()); stream = null; }
            statusEl.textContent = 'Stopped';
            startBtn.disabled = false;
            stopBtn.disabled = true;
            announceBtn.disabled = true;
            mapContainer.classList.remove('visible');
        });

        // ‚îÄ‚îÄ‚îÄ WEBSOCKET (optimized: backpressure + adaptive rate) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let awaitingResponse = false;
        let sendTimestamp = 0;
        let adaptiveInterval = 150;
        let sendIntervalId = null;
        let fpsCount = 0;
        let fpsTimer = Date.now();
        let currentFps = 0;
        let currentRtt = 0;

        const sendCanvas = document.createElement('canvas');
        const sendCtx = sendCanvas.getContext('2d');
        const SEND_WIDTH = 240;

        function connectWebSocket() {
            const wsUrl = serverUrl.replace('http', 'ws') + '/ws/video';
            ws = new WebSocket(wsUrl);
            ws.onopen = () => {
                isProcessing = true;
                awaitingResponse = false;
                startSendLoop();
            };
            ws.onmessage = (ev) => {
                try {
                    const data = JSON.parse(ev.data);
                    if (data.error) { awaitingResponse = false; return; }

                    const rtt = Date.now() - sendTimestamp;
                    currentRtt = rtt;
                    adaptiveInterval = Math.max(80, Math.min(800, Math.round(rtt * 1.6)));

                    fpsCount++;
                    const now = Date.now();
                    if (now - fpsTimer >= 1000) {
                        currentFps = fpsCount;
                        fpsCount = 0;
                        fpsTimer = now;
                    }

                    if (data.frame_base64) {
                        processedFrame.src = 'data:image/jpeg;base64,' + data.frame_base64;
                        videoContainer.classList.remove('show-video');
                    }
                    if (data.objects) { lastDetections = data.objects; updateDetectionsList(data.objects); }
                    if (data.instruction) lastSpokenAnnouncement = data.instruction;

                    awaitingResponse = false;
                } catch (e) {
                    console.error("WS parse error", e);
                    awaitingResponse = false;
                }
            };
            ws.onerror = () => {
                statusEl.textContent = 'WebSocket error';
                statusEl.style.color = '#fca5a5';
                awaitingResponse = false;
            };
            ws.onclose = () => {
                stopSendLoop();
                if (isProcessing) setTimeout(connectWebSocket, 2000);
            };
        }

        function startSendLoop() {
            if (sendIntervalId) return;
            sendIntervalId = setInterval(trySendFrame, 80);
        }

        function stopSendLoop() {
            if (sendIntervalId) { clearInterval(sendIntervalId); sendIntervalId = null; }
        }

        function trySendFrame() {
            if (awaitingResponse) return;
            if (!videoEl.videoWidth || !ws || ws.readyState !== WebSocket.OPEN) return;

            const scale = SEND_WIDTH / videoEl.videoWidth;
            const h = Math.round(videoEl.videoHeight * scale);
            if (sendCanvas.width !== SEND_WIDTH || sendCanvas.height !== h) {
                sendCanvas.width = SEND_WIDTH;
                sendCanvas.height = h;
            }

            sendCtx.drawImage(videoEl, 0, 0, sendCanvas.width, sendCanvas.height);
            sendCanvas.toBlob(blob => {
                if (!blob || !ws || ws.readyState !== WebSocket.OPEN) return;
                const reader = new FileReader();
                reader.onload = () => {
                    awaitingResponse = true;
                    sendTimestamp = Date.now();
                    ws.send(reader.result.split(',')[1]);
                };
                reader.readAsDataURL(blob);
            }, 'image/jpeg', 0.35);
        }

        // ‚îÄ‚îÄ‚îÄ ANNOUNCE (What's Ahead) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        announceBtn.addEventListener('click', async () => {
            if (!videoEl.videoWidth || !serverUrl) return;

            if (isSpeakingEL) {
                stopAllAudio();
                statusEl.textContent = 'Stopped speaking';
                return;
            }

            announceBtn.disabled = true;
            statusEl.textContent = 'Analyzing scene‚Ä¶';
            try {
                const canvas = document.createElement('canvas');
                const scale = Math.min(1, 640 / videoEl.videoWidth);
                canvas.width = videoEl.videoWidth * scale;
                canvas.height = videoEl.videoHeight * scale;
                canvas.getContext('2d').drawImage(videoEl, 0, 0, canvas.width, canvas.height);
                const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.6));
                const form = new FormData();
                form.append('file', blob, 'scene.jpg');
                if (isNavigating && navDestination) form.append('navigation_context', 'User is heading to room ' + navDestination + '. Give step-based verbal directions using number of steps (e.g. go 3 steps forward, take 2 steps to your right).');

                const res = await fetch(serverUrl + '/analyze-and-announce', { method: 'POST', body: form });
                if (!res.ok) throw new Error('Server ' + res.status);

                const data = await res.json();
                const announcement = (data.announcement || "I couldn't analyze the scene.").trim();

                // Show braille text if detected
                if (data.braille_text) {
                    braillePanel.style.display = 'block';
                    brailleTextEl.textContent = data.braille_text;
                } else {
                    braillePanel.style.display = 'none';
                    brailleTextEl.textContent = '';
                }

                if (data.frame_base64) {
                    processedFrame.src = 'data:image/jpeg;base64,' + data.frame_base64;
                    videoContainer.classList.remove('show-video');
                }
                statusEl.textContent = 'üó£Ô∏è Speaking‚Ä¶';
                await speakWithElevenLabs(announcement);
                lastSpokenAnnouncement = announcement;
            } catch (err) {
                console.error(err);
                statusEl.textContent = 'Error: ' + err.message;
                speak(lastSpokenAnnouncement || "Something went wrong. Check the server connection.");
            }
            announceBtn.disabled = false;
            if (isProcessing) statusEl.textContent = isNavigating
                ? 'üß≠ Navigating to room ' + navDestination
                : 'Camera on ‚Äî tap Navigate for step-by-step guidance';
        });

        // ‚îÄ‚îÄ‚îÄ DETECTIONS LIST ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function updateDetectionsList(objects) {
            if (!objects?.length) { detectionList.innerHTML = '<em style="color:var(--color-text-muted)">Path clear</em>'; return; }
            objects.sort((a, b) => (a.distance ?? 999) - (b.distance ?? 999));
            detectionList.innerHTML = objects.map(obj => {
                const d = obj.distance;
                let cls = 'distance-far', text = '‚Äî';
                if (d != null) {
                    const steps = Math.max(1, Math.round(d / 0.75));
                    const stepLabel = steps === 1 ? 'step' : 'steps';
                    if (d < 1) { cls = 'distance-close'; text = steps + ' ' + stepLabel + ' ‚ö†'; }
                    else if (d < 2) { cls = 'distance-medium'; text = steps + ' ' + stepLabel; }
                    else text = steps + ' ' + stepLabel;
                }
                return `<div class="detection-item"><span>${obj.label}</span><span class="${cls}">${text}</span></div>`;
            }).join('');
        }

        // ‚îÄ‚îÄ‚îÄ VOICE NAVIGATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        voiceNavBtn.addEventListener('click', () => {
            if (isNavigating) { stopNavigation(); return; }
            startVoiceRecognition();
        });

        function startVoiceRecognition() {
            const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
            if (!SR) {
                manualEntry.classList.add('visible');
                statusEl.textContent = 'Voice not supported ‚Äî type room above';
                return;
            }
            recognition = new SR();
            recognition.continuous = false;
            recognition.interimResults = false;
            recognition.lang = 'en-US';
            recognition.onstart = () => {
                statusEl.textContent = 'üé§ Listening‚Ä¶';
                voiceNavBtn.textContent = 'üõë Cancel';
                voiceNavBtn.classList.add('active-nav');
            };
            recognition.onresult = (ev) => {
                const cmd = ev.results[0][0].transcript;
                statusEl.textContent = `Heard: "${cmd}"`;
                parseNavigationCommand(cmd);
            };
            recognition.onerror = () => {
                statusEl.textContent = 'Try again or type room number';
                manualEntry.classList.add('visible');
                resetVoiceBtn();
            };
            recognition.onend = () => resetVoiceBtn();
            recognition.start();
        }

        function resetVoiceBtn() {
            voiceNavBtn.textContent = 'üé§ Navigate';
            voiceNavBtn.classList.remove('active-nav');
        }

        document.getElementById('goBtn').addEventListener('click', () => {
            const dest = document.getElementById('manualDest').value.trim();
            if (dest) parseNavigationCommand('go to room ' + dest);
        });

        // ‚îÄ‚îÄ‚îÄ NAVIGATION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        async function parseNavigationCommand(text) {
            statusEl.textContent = 'Finding route‚Ä¶';
            try {
                const res = await fetch(`${serverUrl}/navigate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, start_room: START_ROOM })
                });

                if (!res.ok) {
                   const errText = await res.text();
                   throw new Error(errText || 'Navigation failed');
                }

                const data = await res.json();
                if (data.error) throw new Error(data.error);

                startNavigation(data);
            } catch (err) {
                console.error(err);
                statusEl.textContent = '‚ùå ' + (err.message || "Failed to find path");
                speak("I couldn't find a path to that room.");
                manualEntry.classList.add('visible');
            }
        }

        function startNavigation(data) {
            if (isNavigating) stopNavigation();

            isNavigating = true;
            navPath = data.path || [];
            navDestination = data.destination || '?';

            navInfo.textContent = 'Navigating to Room ' + navDestination;
            if (serverUrl && !mapImg.src) mapImg.src = serverUrl + '/static/floor_plans/basement.png';
            mapContainer.classList.add('visible');
            voiceNavBtn.textContent = 'üõë Stop';
            voiceNavBtn.classList.add('active-nav');
            statusEl.textContent = 'üß≠ Navigating to room ' + navDestination;

            speakWithElevenLabs(data.instruction || `Heading to room ${navDestination}. I will guide you every 3 seconds with step-by-step directions.`);

            setTimeout(() => {
                startPositionTracking();
            }, 300);

            startDynamicGuidance();
        }

        function stopNavigation() {
            isNavigating = false;
            stopPositionTracking();
            stopAllAudio();

            const ctx = routeCanvas.getContext('2d');
            ctx.clearRect(0, 0, routeCanvas.width, routeCanvas.height);

            if (guidanceInterval) { clearInterval(guidanceInterval); guidanceInterval = null; }
            mapContainer.classList.remove('visible');
            resetVoiceBtn();
            statusEl.textContent = 'Navigation stopped';
        }

        // ‚îÄ‚îÄ‚îÄ DYNAMIC GUIDANCE (every 3s with overlap protection) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        let guidanceInFlight = false;

        function startDynamicGuidance() {
            if (guidanceInterval) clearInterval(guidanceInterval);

            const navContext = `User is heading to room ${navDestination}. Give step-based verbal directions using number of steps (e.g. "go 3 steps forward", "take 2 steps to your right").`;

            guidanceInterval = setInterval(async () => {
                if (!isNavigating || !isProcessing || !videoEl.videoWidth || isSpeakingEL || guidanceInFlight) return;

                guidanceInFlight = true;
                try {
                    const canvas = document.createElement('canvas');
                    const scale = Math.min(1, 640 / videoEl.videoWidth);
                    canvas.width = videoEl.videoWidth * scale;
                    canvas.height = videoEl.videoHeight * scale;
                    canvas.getContext('2d').drawImage(videoEl, 0, 0, canvas.width, canvas.height);
                    const blob = await new Promise(r => canvas.toBlob(r, 'image/jpeg', 0.6));
                    const form = new FormData();
                    form.append('file', blob, 'scene.jpg');
                    form.append('navigation_context', navContext);

                    const res = await fetch(`${serverUrl}/analyze-and-announce`, { method: 'POST', body: form });
                    const data = await res.json();
                    const announcement = data.announcement;

                    // Update braille indicator during navigation too
                    if (data.braille_text) {
                        braillePanel.style.display = 'block';
                        brailleTextEl.textContent = data.braille_text;
                    }

                    if (announcement && !isSpeakingEL) {
                        statusEl.textContent = 'üó£Ô∏è ' + announcement.slice(0, 50) + '‚Ä¶';
                        await speakWithElevenLabs(announcement);
                    }
                } catch (e) { console.warn('Guidance:', e); }
                guidanceInFlight = false;
            }, 3000);
        }

        // ‚îÄ‚îÄ‚îÄ INIT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        window.addEventListener('load', () => {
            const host = window.location.hostname;
            const port = window.location.port;
            if (host !== 'localhost' && host !== '127.0.0.1') serverUrlInput.value = host + ':8000';
            else serverUrlInput.value = 'localhost:8000';
            if (port === '8000' || window.location.origin.includes('8000')) {
                serverUrl = window.location.origin;
                setMapSource();
            }
        });
    </script>
</body>
</html>
